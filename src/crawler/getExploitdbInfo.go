package crawler

import (
	"crush/database"
	"crush/utils"
	"encoding/json"
	"fmt"
	"html"
	"io"
	"io/ioutil"
	"log"
	"math"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"time"
)

const (
	edbURL       = "https://www.exploit-db.com/?draw=1&columns%5B0%5D%5Bdata%5D=date_published&columns%5B0%5D%5Bname%5D=date_published&columns%5B0%5D%5Bsearchable%5D=true&columns%5B0%5D%5Borderable%5D=true&columns%5B0%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B0%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B1%5D%5Bdata%5D=download&columns%5B1%5D%5Bname%5D=download&columns%5B1%5D%5Bsearchable%5D=false&columns%5B1%5D%5Borderable%5D=false&columns%5B1%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B1%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B2%5D%5Bdata%5D=application_md5&columns%5B2%5D%5Bname%5D=application_md5&columns%5B2%5D%5Bsearchable%5D=true&columns%5B2%5D%5Borderable%5D=false&columns%5B2%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B2%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B3%5D%5Bdata%5D=verified&columns%5B3%5D%5Bname%5D=verified&columns%5B3%5D%5Bsearchable%5D=true&columns%5B3%5D%5Borderable%5D=false&columns%5B3%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B3%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B4%5D%5Bdata%5D=description&columns%5B4%5D%5Bname%5D=description&columns%5B4%5D%5Bsearchable%5D=true&columns%5B4%5D%5Borderable%5D=false&columns%5B4%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B4%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B5%5D%5Bdata%5D=type_id&columns%5B5%5D%5Bname%5D=type_id&columns%5B5%5D%5Bsearchable%5D=true&columns%5B5%5D%5Borderable%5D=false&columns%5B5%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B5%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B6%5D%5Bdata%5D=platform_id&columns%5B6%5D%5Bname%5D=platform_id&columns%5B6%5D%5Bsearchable%5D=true&columns%5B6%5D%5Borderable%5D=false&columns%5B6%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B6%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B7%5D%5Bdata%5D=author_id&columns%5B7%5D%5Bname%5D=author_id&columns%5B7%5D%5Bsearchable%5D=false&columns%5B7%5D%5Borderable%5D=false&columns%5B7%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B7%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B8%5D%5Bdata%5D=code&columns%5B8%5D%5Bname%5D=code.code&columns%5B8%5D%5Bsearchable%5D=true&columns%5B8%5D%5Borderable%5D=true&columns%5B8%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B8%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B9%5D%5Bdata%5D=id&columns%5B9%5D%5Bname%5D=id&columns%5B9%5D%5Bsearchable%5D=false&columns%5B9%5D%5Borderable%5D=true&columns%5B9%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B9%5D%5Bsearch%5D%5Bregex%5D=false&order%5B0%5D%5Bcolumn%5D=9&order%5B0%5D%5Bdir%5D=desc&search%5Bvalue%5D=&search%5Bregex%5D=false&author=&port=&type=&tag=&platform=&_=1701330571815"
	itemsPerpage = 60
)

var (
	edblogDir         = filepath.Join(utils.GetParentPath(), "data", "exploitdb", "log")
	edbupdateInfoPath = filepath.Join(edblogDir, "edb_update_info.log")
	exploitDir        = cfg.Exploitdb.ExploitdbDir
)

var (
	edbHeaders = map[string]string{
		"Host":               "www.exploit-db.com",
		"Cookie":             "CookieConsent={stamp:%27-1%27%2Cnecessary:true%2Cpreferences:true%2Cstatistics:true%2Cmarketing:true%2Cmethod:%27implied%27%2Cver:1%2Cutc:1698739761982%2Cregion:%27CN%27}; _ga=GA1.3.1653474217.1698739778; _ga_N0K6XSDCRJ=GS1.3.1701140915.4.0.1701140915.60.0.0; XSRF-TOKEN=eyJpdiI6ImJLMm92Z0ZTTmpJMXhlS0RKcFk4UGc9PSIsInZhbHVlIjoid2luTUZxTVJZbm1OazEyeXNmdlcxajhrelVRWmF0dmF2YWVVZHhuTnNiaxg4akNSWEpaMCtpYVJHOXk0V0ZwXC8iLCJtYWMiOiI4NjBjNDUwM2VmNmJlNzk4N2YwNDA1YzJjNmY5NGYwMjRlZWM5OGM3MzM1MmRjYzM0YmMwZTY5MzcwMDU1ZjYyIn0%3D; exploit_database_session=eyJpdiI6IlVBTVZHbGkyUlwvemxCUzQxeEFES05RPT0iLCJ2YWx1IjoiIlFzOFdhVjhyN1FKbWZaV3V6Tm5ORHYweXI0MmdvalozOEhzd0oxakFLcFVaQ2pmQWFSYVZGdVlpTThTeU94NWsiLCJtYWMiOiI1ZTMzZDc2YTc1MWI2ZThjMWU5M2RhNzAzNmY4YTdlMTViMDZhMzIzNjQ2NjQzMWU4M2QxNDBjMjU5NWIwNmRhIn0%3D",
		"Sec-Ch-Ua":          "",
		"Accept":             "application/json, text/javascript, */*; q=0.01",
		"X-Requested-With":   "XMLHttpRequest",
		"Sec-Ch-Ua-Mobile":   "?0",
		"User-Agent":         "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5845.111 Safari/537.36",
		"Sec-Ch-Ua-Platform": "",
		"Sec-Fetch-Site":     "same-origin",
		"Sec-Fetch-Mode":     "cors",
		"Sec-Fetch-Dest":     "empty",
		"Referer":            "https://www.exploit-db.com/",
		"Accept-Encoding":    "gzip, deflate, br",
		"Accept-Language":    "zh-CN,zh;q=0.9",
	}
)

// concurrency
var semaphore = make(chan struct{}, 20)

func getTotal() int {
	url := edbURL + "&start=0&length=15"
	method := "GET"

	client := &http.Client{}

	req, err := http.NewRequest(method, url, nil)
	if err != nil {
		utils.PrintColor("error", "Error creating request:", err, "\n")
		return 0
	}

	utils.SetHeaders(req, edbHeaders)

	res, err := client.Do(req)
	if err != nil {
		utils.PrintColor("error", "Error sending request:", err, "\n")
		return 0
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			utils.PrintColor("error", "Error closing connection:", err, "\n")
			return
		}
	}(res.Body)

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		utils.PrintColor("error", "Error reading response:", err, "\n")
		return 0
	}

	var data map[string]interface{}
	if err := json.Unmarshal(body, &data); err != nil {
		utils.PrintColor("error", "Error parsing into json:", err, "\n")
		return 0
	}

	total := int(data["recordsTotal"].(float64))
	utils.PrintColor("info", "total num of vulnerabilities in exploit_db is "+strconv.Itoa(total))
	return total

}

func CheckEdbUpdate() string {
	yesterday := time.Now().AddDate(0, 0, -1)
	var result strings.Builder
	dbcount, _ := database.CheckCount()
	yescount := getTotal()
	if yescount == dbcount {
		result.WriteString("Already up to date.")
	} else {
		url := edbURL + "&start=0&length=60"
		method := "GET"

		client := &http.Client{}

		req, err := http.NewRequest(method, url, nil)
		if err != nil {
			utils.PrintColor("error", "Error creating request:", err, "\n")
			return ""
		}

		for key, value := range edbHeaders {
			req.Header.Add(key, value)
		}

		res, err := client.Do(req)
		if err != nil {
			utils.PrintColor("error", "Error sending request:", err, "\n")
			return ""
		}
		defer func(Body io.ReadCloser) {
			err := Body.Close()
			if err != nil {
				utils.PrintColor("error", "Error closing connection:", err, "\n")
				return
			}
		}(res.Body)

		body, err := ioutil.ReadAll(res.Body)
		if err != nil {
			utils.PrintColor("error", "Error reading response:", err, "\n")
			return ""
		}

		var data map[string]interface{}
		if err := json.Unmarshal(body, &data); err != nil {
			utils.PrintColor("error", "Error parsing into json:", err, "\n")
			return ""
		}

		for _, item := range data["data"].([]interface{}) {
			itemData := item.(map[string]interface{})
			extractedData := map[string]interface{}{
				"id":             itemData["id"],
				"description":    itemData["description"],
				"type_id":        itemData["type_id"],
				"platform_id":    itemData["platform_id"],
				"date_published": itemData["date_published"],
				"verified":       itemData["verified"],
				"code":           itemData["code"],
			}

			id, _ := strconv.Atoi(extractedData["id"].(string))
			desc := html.UnescapeString(extractedData["description"].([]interface{})[1].(string))
			type_id := extractedData["type_id"].(string)
			platform_id := extractedData["platform_id"].(string)
			dateString := extractedData["date_published"].(string)
			date_published, _ := time.Parse("2006-01-02", dateString)
			verified := int(extractedData["verified"].(float64))

			codeByType := make(map[string][]interface{})
			for _, codeItem := range extractedData["code"].([]interface{}) {
				codeData := codeItem.(map[string]interface{})
				codeType := codeData["code_type"].(string)
				if codeType == "cve" || codeType == "osvdb" {
					codeByType[codeType] = append(codeByType[codeType], strings.ToUpper(codeType)+"-"+codeData["code"].(string))
				} else {
					codeByType["others"] = append(codeByType["others"], strings.ToUpper(codeType)+"-"+codeData["code"].(string))
				}

			}
			if date_published.Year() == yesterday.Year() && date_published.Month() == yesterday.Month() && date_published.Day() == yesterday.Day() {
				//TODO
				utils.PrintColor("info", "Exploitdb Vul Updated: "+strconv.Itoa(id))
				database.InsertEDB(id, desc, type_id, platform_id, date_published, verified, utils.ConvertToString(codeByType["cve"]), utils.ConvertToString(codeByType["osvdb"]), utils.ConvertToString(codeByType["others"]))
				err = DownloadEdbPoc(id)
				if err != nil {
					log.Fatal("Download poc err", err)
				}
				result.WriteString(strconv.Itoa(id) + " " + desc + " " + type_id + " " + platform_id + " " + date_published.Format("2006-01-02") + " " + strconv.Itoa(verified) + " " + utils.ConvertToString(codeByType["cve"]) + " " + utils.ConvertToString(codeByType["osvdb"]) + " " + utils.ConvertToString(codeByType["others"]) + "\n")
			}
		}
		//else
	}
	utils.WriteToLog(yesterday.Format("2006-01-02")+"\n"+result.String(), edbupdateInfoPath)
	return result.String()
}

func FetchEDB(start int, length int, wg *sync.WaitGroup, successChan chan struct{}) {
	defer wg.Done()
	defer func() {
		//释放信号量，允许其他协程执行
		<-semaphore
	}()
	//获取信号量，控制并发数
	semaphore <- struct{}{}

	startStr := strconv.Itoa(start)
	lenStr := strconv.Itoa(length)
	url := edbURL + "&start=" + startStr + "&length=" + lenStr
	method := "GET"

	client := &http.Client{}

	req, err := http.NewRequest(method, url, nil)
	if err != nil {
		utils.PrintColor("error", "Error creating request:", err, "\n")
		return
	}

	for key, value := range edbHeaders {
		req.Header.Add(key, value)
	}

	res, err := client.Do(req)
	if err != nil {
		utils.PrintColor("error", "Error sending request:", err, "\n")
		return
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			utils.PrintColor("error", "Error closing connection:", err, "\n")
			return
		}
	}(res.Body)

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		utils.PrintColor("error", "Error reading response:", err, "\n")
		return
	}

	var data map[string]interface{}
	if err := json.Unmarshal(body, &data); err != nil {
		utils.PrintColor("error", "Error parsing into json:", err, "\n")
		return
	}

	for _, item := range data["data"].([]interface{}) {
		itemData := item.(map[string]interface{})
		extractedData := map[string]interface{}{
			"id":             itemData["id"],
			"description":    itemData["description"],
			"type_id":        itemData["type_id"],
			"platform_id":    itemData["platform_id"],
			"date_published": itemData["date_published"],
			"verified":       itemData["verified"],
			"code":           itemData["code"],
		}

		id, _ := strconv.Atoi(extractedData["id"].(string))
		desc := html.UnescapeString(extractedData["description"].([]interface{})[1].(string))
		type_id := extractedData["type_id"].(string)
		platform_id := extractedData["platform_id"].(string)
		dateString := extractedData["date_published"].(string)
		date_published, _ := time.Parse("2006-01-02", dateString)
		verified := int(extractedData["verified"].(float64))

		codeByType := make(map[string][]interface{})
		for _, codeItem := range extractedData["code"].([]interface{}) {
			codeData := codeItem.(map[string]interface{})
			codeType := codeData["code_type"].(string)
			if codeType == "cve" || codeType == "osvdb" {
				codeByType[codeType] = append(codeByType[codeType], strings.ToUpper(codeType)+"-"+codeData["code"].(string))
			} else {
				codeByType["others"] = append(codeByType["others"], strings.ToUpper(codeType)+"-"+codeData["code"].(string))
			}

		}

		err = database.InsertEDB(id, desc, type_id, platform_id, date_published, verified, utils.ConvertToString(codeByType["cve"]), utils.ConvertToString(codeByType["osvdb"]), utils.ConvertToString(codeByType["others"]))
		if err != nil {
			utils.PrintColor("error", "Error inserting vul %d into db:%v\n", id, err)
			return
		}
		/*
			err := DownloadEdbPoc(id)
			if err != nil {
				fmt.Printf("poc %d download err", id, err)
				continue
			}


		*/
		successChan <- struct{}{}

	}
}

func ConcurrentEDBCrawler() {
	var wg sync.WaitGroup
	successChan := make(chan struct{})

	total := getTotal()
	totalPages := int(math.Ceil(float64(total) / float64(itemsPerpage)))
	for page := 1; page <= totalPages; page++ {
		start := (page - 1) * itemsPerpage
		wg.Add(1)
		go FetchEDB(start, itemsPerpage, &wg, successChan)
	}

	go func() {
		wg.Wait()
		close(successChan)
	}()

	successCount := 0
	for range successChan {
		successCount++
	}

	utils.PrintColor("success", "Exploit-db: Successfully insert %d vul info", successCount)
}

func DownloadEdbPoc(id int) error {
	time.Sleep(time.Millisecond * 500)
	pocurl := fmt.Sprintf("https://www.exploit-db.com/download/%d", id)
	resp, err := http.Get(pocurl)
	if err != nil {
		return fmt.Errorf("failed to download POC: %v", err)
	}
	defer resp.Body.Close()

	saveDir := fmt.Sprintf("%s%d", exploitDir, id)
	err = os.MkdirAll(saveDir, 0755)
	if err != nil && !os.IsExist(err) {
		return fmt.Errorf("failed to create directory: %v", err)
	}

	contentDisposition := resp.Header.Get("Content-Disposition")
	fileName := "poc"
	if contentDisposition != "" {
		idx := strings.Index(contentDisposition, "filename=")
		if idx != -1 {
			fileName = contentDisposition[idx+len("filename="):]
			fileName = strings.Trim(fileName, "\" ")
		}
	}
	savePath := filepath.Join(saveDir, fileName)
	file, err := os.Create(savePath)
	if err != nil {
		return fmt.Errorf("failed to create file: %v", err)
	}
	defer file.Close()

	_, err = io.Copy(file, resp.Body)
	if err != nil {
		return fmt.Errorf("failed to save file: %v", err)
	}
	return nil

}
