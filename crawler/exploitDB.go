package crawler

import (
	"crush/database"
	"crush/utils"
	"encoding/json"
	"fmt"
	"html"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

const edbURL = "https://www.exploit-db.com/?draw=1&columns%5B0%5D%5Bdata%5D=date_published&columns%5B0%5D%5Bname%5D=date_published&columns%5B0%5D%5Bsearchable%5D=true&columns%5B0%5D%5Borderable%5D=true&columns%5B0%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B0%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B1%5D%5Bdata%5D=download&columns%5B1%5D%5Bname%5D=download&columns%5B1%5D%5Bsearchable%5D=false&columns%5B1%5D%5Borderable%5D=false&columns%5B1%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B1%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B2%5D%5Bdata%5D=application_md5&columns%5B2%5D%5Bname%5D=application_md5&columns%5B2%5D%5Bsearchable%5D=true&columns%5B2%5D%5Borderable%5D=false&columns%5B2%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B2%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B3%5D%5Bdata%5D=verified&columns%5B3%5D%5Bname%5D=verified&columns%5B3%5D%5Bsearchable%5D=true&columns%5B3%5D%5Borderable%5D=false&columns%5B3%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B3%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B4%5D%5Bdata%5D=description&columns%5B4%5D%5Bname%5D=description&columns%5B4%5D%5Bsearchable%5D=true&columns%5B4%5D%5Borderable%5D=false&columns%5B4%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B4%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B5%5D%5Bdata%5D=type_id&columns%5B5%5D%5Bname%5D=type_id&columns%5B5%5D%5Bsearchable%5D=true&columns%5B5%5D%5Borderable%5D=false&columns%5B5%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B5%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B6%5D%5Bdata%5D=platform_id&columns%5B6%5D%5Bname%5D=platform_id&columns%5B6%5D%5Bsearchable%5D=true&columns%5B6%5D%5Borderable%5D=false&columns%5B6%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B6%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B7%5D%5Bdata%5D=author_id&columns%5B7%5D%5Bname%5D=author_id&columns%5B7%5D%5Bsearchable%5D=false&columns%5B7%5D%5Borderable%5D=false&columns%5B7%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B7%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B8%5D%5Bdata%5D=code&columns%5B8%5D%5Bname%5D=code.code&columns%5B8%5D%5Bsearchable%5D=true&columns%5B8%5D%5Borderable%5D=true&columns%5B8%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B8%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B9%5D%5Bdata%5D=id&columns%5B9%5D%5Bname%5D=id&columns%5B9%5D%5Bsearchable%5D=false&columns%5B9%5D%5Borderable%5D=true&columns%5B9%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B9%5D%5Bsearch%5D%5Bregex%5D=false&order%5B0%5D%5Bcolumn%5D=9&order%5B0%5D%5Bdir%5D=desc&search%5Bvalue%5D=&search%5Bregex%5D=false&author=&port=&type=&tag=&platform=&_=1701330571815"

var (
	EdblogDir         = filepath.Join(utils.GetCurrentPath(), "data", "exploitdb")
	EdbUpdateInfoPath = filepath.Join(EdblogDir, "edb_update_info.log")
	EdbPocDir         = cfg.Exploitdb.EdbPocDir
)

var (
	edbHeaders = map[string]string{
		"Host":               "www.exploit-db.com",
		"Cookie":             "CookieConsent={stamp:%27-1%27%2Cnecessary:true%2Cpreferences:true%2Cstatistics:true%2Cmarketing:true%2Cmethod:%27implied%27%2Cver:1%2Cutc:1698739761982%2Cregion:%27CN%27}; _ga=GA1.3.1653474217.1698739778; _ga_N0K6XSDCRJ=GS1.3.1701140915.4.0.1701140915.60.0.0; XSRF-TOKEN=eyJpdiI6ImJLMm92Z0ZTTmpJMXhlS0RKcFk4UGc9PSIsInZhbHVlIjoid2luTUZxTVJZbm1OazEyeXNmdlcxajhrelVRWmF0dmF2YWVVZHhuTnNiaxg4akNSWEpaMCtpYVJHOXk0V0ZwXC8iLCJtYWMiOiI4NjBjNDUwM2VmNmJlNzk4N2YwNDA1YzJjNmY5NGYwMjRlZWM5OGM3MzM1MmRjYzM0YmMwZTY5MzcwMDU1ZjYyIn0%3D; exploit_database_session=eyJpdiI6IlVBTVZHbGkyUlwvemxCUzQxeEFES05RPT0iLCJ2YWx1IjoiIlFzOFdhVjhyN1FKbWZaV3V6Tm5ORHYweXI0MmdvalozOEhzd0oxakFLcFVaQ2pmQWFSYVZGdVlpTThTeU94NWsiLCJtYWMiOiI1ZTMzZDc2YTc1MWI2ZThjMWU5M2RhNzAzNmY4YTdlMTViMDZhMzIzNjQ2NjQzMWU4M2QxNDBjMjU5NWIwNmRhIn0%3D",
		"Sec-Ch-Ua":          "",
		"Accept":             "application/json, text/javascript, */*; q=0.01",
		"X-Requested-With":   "XMLHttpRequest",
		"Sec-Ch-Ua-Mobile":   "?0",
		"User-Agent":         "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5845.111 Safari/537.36",
		"Sec-Ch-Ua-Platform": "",
		"Sec-Fetch-Site":     "same-origin",
		"Sec-Fetch-Mode":     "cors",
		"Sec-Fetch-Dest":     "empty",
		"Referer":            "https://www.exploit-db.com/",
		"Accept-Encoding":    "gzip, deflate, br",
		"Accept-Language":    "zh-CN,zh;q=0.9",
	}
)

func CheckEdbUpdate() string {
	var result strings.Builder
	updated := false
	url := edbURL + "&start=0&length=60"
	method := "GET"

	client := &http.Client{}

	req, err := http.NewRequest(method, url, nil)
	if err != nil {
		utils.PrintLog("error", "Error creating request:", err, "\n")
		return ""
	}

	for key, value := range edbHeaders {
		req.Header.Add(key, value)
	}

	res, err := client.Do(req)
	if err != nil {
		utils.PrintLog("error", "Error sending request:", err, "\n")
		return ""
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			utils.PrintLog("error", "Error closing connection:", err, "\n")
			return
		}
	}(res.Body)

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		utils.PrintLog("error", "Error reading response:", err, "\n")
		return ""
	}

	var data map[string]interface{}
	if err := json.Unmarshal(body, &data); err != nil {
		utils.PrintLog("error", "Error parsing into json:", err, "\n")
		return ""
	}

	vulnerabilities := []Vulnerability{}
	for _, item := range data["data"].([]interface{}) {
		itemData := item.(map[string]interface{})
		extractedData := map[string]interface{}{
			"id":             itemData["id"],
			"description":    itemData["description"],
			"type_id":        itemData["type_id"],
			"platform_id":    itemData["platform_id"],
			"date_published": itemData["date_published"],
			"verified":       itemData["verified"],
			"code":           itemData["code"],
		}

		id, _ := strconv.Atoi(extractedData["id"].(string))
		desc := html.UnescapeString(extractedData["description"].([]interface{})[1].(string))
		typeId := extractedData["type_id"].(string)
		platformId := extractedData["platform_id"].(string)
		dateString := extractedData["date_published"].(string)
		datePublished, _ := time.Parse("2006-01-02", dateString)
		verified := int(extractedData["verified"].(float64))

		codeByType := make(map[string][]interface{})
		for _, codeItem := range extractedData["code"].([]interface{}) {
			codeData := codeItem.(map[string]interface{})
			codeType := codeData["code_type"].(string)
			if codeType == "cve" || codeType == "osvdb" {
				codeByType[codeType] = append(codeByType[codeType], strings.ToUpper(codeType)+"-"+codeData["code"].(string))
			} else {
				codeByType["others"] = append(codeByType["others"], strings.ToUpper(codeType)+"-"+codeData["code"].(string))
			}

		}
		if datePublished.Year() == Yesterday.Year() && datePublished.Month() == Yesterday.Month() && datePublished.Day() == Yesterday.Day() {
			updated = true
			database.InsertEDB(id, desc, typeId, platformId, datePublished, verified, utils.ConvertToString(codeByType["cve"]), utils.ConvertToString(codeByType["osvdb"]), utils.ConvertToString(codeByType["others"]))

			if DownloadPOC == true {
				err = DownloadEdbPoc(id)
				if err != nil {
					log.Fatal("Download poc err", err)
				}
			}

			url := "https://www.exploit-db.com/exploits/" + strconv.Itoa(id)
			result.WriteString(fmt.Sprintf("%s %s\n", desc, utils.ConvertToString(codeByType["cve"])))
			vulnerabilities = append(vulnerabilities, Vulnerability{
				Name:   desc,
				CVE:    utils.ConvertToString(codeByType["cve"]),
				URL:    url,
				Source: "exploit-db",
			})
		}
	}
	if !updated {
		result.WriteString("Already up to date.")
		utils.PrintLog("info", "exploit-db is up to date")
	} else {
		utils.PrintLog("success", "exploit-db update")
		jsonData, _ := json.MarshalIndent(vulnerabilities, "", "    ")
		utils.WriteToLog(string(jsonData), JsonlogPath)
	}
	utils.WriteToLog(Yesterday.Format("2006-01-02")+"\n"+result.String(), EdbUpdateInfoPath)
	return result.String()
}

func DownloadEdbPoc(id int) error {
	time.Sleep(time.Millisecond * 500)
	pocurl := fmt.Sprintf("https://www.exploit-db.com/download/%d", id)
	resp, err := http.Get(pocurl)
	if err != nil {
		return fmt.Errorf("failed to download POC: %v", err)
	}
	defer resp.Body.Close()

	saveDir := fmt.Sprintf("%s%d", EdbPocDir, id)
	err = os.MkdirAll(saveDir, 0755)
	if err != nil && !os.IsExist(err) {
		return fmt.Errorf("failed to create directory: %v", err)
	}

	contentDisposition := resp.Header.Get("Content-Disposition")
	fileName := "poc"
	if contentDisposition != "" {
		idx := strings.Index(contentDisposition, "filename=")
		if idx != -1 {
			fileName = contentDisposition[idx+len("filename="):]
			fileName = strings.Trim(fileName, "\" ")
		}
	}
	savePath := filepath.Join(saveDir, fileName)
	file, err := os.Create(savePath)
	if err != nil {
		return fmt.Errorf("failed to create file: %v", err)
	}
	defer file.Close()

	_, err = io.Copy(file, resp.Body)
	if err != nil {
		return fmt.Errorf("failed to save file: %v", err)
	}
	return nil

}
